# CPU设计文档

## 一、CPU设计方案综述

### （一）总体设计概述

本CPU为Verilog实现的单周期MIPS - CPU，支持的指令集包含

{ addu, subu, or, jr, sll, ori, lw, sw, beq, lui, j, jal, addiu, sb }。

为了实现这些功能，CPU主要包含了IFU、GRF、ALU、DM、Controller，这些模块按照….的顶层设计逐级展开。

### （二）关键模块定义

#### 1. GRF

| 端口  | 输入/输出 | 位宽 |      描述       |
| :---: | :-------: | :--: | :-------------: |
|  CLK  |     I     |  1   |    时钟信号     |
|  WE   |     I     |  1   |  写入使能信号   |
| reset |     I     |  1   |  异步重置信号   |
|  A1   |     I     |  5   | 读取寄存器地址1 |
|  A2   |     I     |  5   | 读取寄存器地址2 |
|  A3   |     I     |  5   | 写入寄存器地址  |
|  WD   |     I     |  32  |    写入数据     |
|  RD1  |     O     |  32  |    读取数据1    |
|  RD2  |     O     |  32  |    读取数据2    |

#### 2. DM

|   端口    | 输入/输出 | 位宽 |      描述      |
| :-------: | :-------: | :--: | :------------: |
|    CLK    |     I     |  1   |    时钟信号    |
|   reset   |     I     |  1   |  异步重置信号  |
| MemWrite  |     I     |  1   | 内存写使能信号 |
|   range   |     I     |  2   | 写入数据的位宽 |
|  Adress   |     I     |  32  |    写入地址    |
| WriteData |     I     |  32  |    写入数据    |
| ReadData  |     O     |  32  |    读取数据    |

其中range信号代表写入数据的原始位宽，用于区分sw、sb、sh等指令。

0代表一字节，1代表半字，0b11代表一字。

#### 3. ALU

|    端口    | 输入/输出 | 位宽 |       描述       |
| :--------: | :-------: | :--: | :--------------: |
| ALUControl |     I     |  3   | 控制ALU运算类型  |
|    SrcA    |     I     |  32  |     运算数A      |
|    SrcB    |     I     |  32  |     运算数B      |
|   shift    |     I     |  5   |     位移位数     |
|  Compare   |     O     |  2   | A和B大小比较结果 |
| ALUResult  |     O     |  32  |     运算结果     |

ALUControl：

0：与运算	1：或运算	0b10：加法运算	0b11：位移运算	0b110：减法运算

使用Compare值时需将ALUControl置为0b110

Compare：

0：A等于B	1：A大于B	0b10：A小于B

#### 4. IFU

|  端口  | 输入/输出 | 位宽 |            描述            |
| :----: | :-------: | :--: | :------------------------: |
| NPCop  |     I     |  2   |       NPC的选择信号        |
|  CLK   |     I     |  1   |          时钟信号          |
| reset  |     I     |  1   |          重置信号          |
| branch |     I     |  32  | 分支指令扩展为32位的立即数 |
|  jump  |     I     |  26  |  j指令扩展为32位的立即数   |
|   jr   |     I     |  32  |   jr指令跳转到的指令地址   |
| Instr  |     O     |  32  |       当前执行的指令       |
|  jal   |     O     |  32  |   jal指令中写入$ra的地址   |

#### 5.Controller

|   端口   | 输入/输出 | 位宽 |           描述           |
| :------: | :-------: | :--: | :----------------------: |
|  opcode  |     I     |  6   |          操作码          |
|  funct   |     I     |  6   |       r指令的功能        |
|   Cmp    |     I     |  2   |       ALU的Compare       |
|  RegDst  |     O     |  2   |      写入寄存器地址      |
|  ALUSrc  |     O     |  2   |   ALU运算数的选择信号    |
| Reg_sel  |     O     |  2   | 寄存器写入数据的选择信号 |
| RegWrite |     O     |  1   |    寄存器写入使能信号    |
| MemWrite |     O     |  1   |     内存写入使能信号     |
| nPC_sel  |     O     |  2   |      NPC的选择信号       |
|  ExtOp   |     O     |  1   |  符号扩展类型的选择信号  |
|  ALUctr  |     O     |  3   |     A控制LU运算类型      |
|  range   |     O     |  2   |     DM写入数据的位宽     |

## 二、测试方案

### 自动测试工具

````python

````

## 三、思考题

（一）现在我们的模块中 IM 使用 ROM， DM 使用 RAM， GRF 使用 Register，这种做法合理吗？ 请给出分析，若有改进意见也请一并给出。

合理。IM中存储需要执行的指令，不需要修改，只要求从外部一次性导入即可，所以使用ROM最为简洁。DM存储大量数据，如果使用寄存器的话造价过于高昂。且DM每次只会存储或读取一个数据，使用RAM即可满足需要。GRF涉及到同时读取两个存储数据并同时存入一个数据，RAM和ROM都无法完成该任务，而GRF所需要的存储单元并不多，所以使用Register。



（二）事实上，实现 nop 空指令，我们并不需要将它加入控制信号真值表，为什么？请给出你的理由。

nop指令并不会对电路的状态造成改变，而电路的Controller在默认情况下RegWrite和MemWrite等都为0，不会改变电路状态，因	此不需要专门把nop加入真值表。还有一点，sll指令的opcode和funct都是0，如果把nop加入真值表，还需要判断opcode和funct	之外的部分。



（三）上文提到，MARS 不能导出 PC 与 DM 起始地址均为 0 的机器码。实际上，可以通过为 DM 增添片选信号，来避免手工修	改的麻烦，请查阅相关资料进行了解，并阐释为了解决这个问题，你最终采用的方法。

我采取的是导出DM起始地址为0，PC起始地址为0x3000的方式，在IFU模块中，对于j指令和jr指令，将它们所用到的地址减去	0x3000。之所以没有采取在jal指令所用的地址做减法，而是选择在jr指令出做减法，是为了应对jr指令调用$ra之外的寄存器，或	者不使用jal指令，通过其他方式对$ra赋值的情况。



（四）除了编写程序进行测试外，还有一种验证 CPU 设计正确性的办法——形式验证。 形式验证的含义是根据某个或某些形式规范	或属性，使用数学的方法证明其正确性或非正确性。请搜索“形式验证（Formal Verification)”了解相关内容后，简要阐述相比于测试，	形式验证的优劣之处。

所谓形式验证，是指从数学上完备地证明或验证电路的实现方案是否确实实现了电路设计所描述的功能。形式验证方法分为等价性验	证、模型检验和定理证明等。

形式验证的优点如下：

(1)形式验证是对指定描述的所有可能的情况进行验证，覆盖率达到了100%。

(2)形式验证技术是借用数学上的方法将待验证电路和功能描述或参考设计直接进行比较，不需要开发测试激励。

(3)形式验证的验证时间短，可以很快发现和改正电路设计中的错误，可以缩短设计周期。

形式验证的缺点：

形式验证到目前为止仍然不能有效地验证电路的性能，如电路的时延和功耗等。

 

 

###  